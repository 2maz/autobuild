module Autobuild
    def self.orogen(opts, &proc)
        Orogen.new(opts, &proc)
    end


    # This discards everything but the calls to import_types_from,
    # using_task_library and using_toolkit. This is used to automatically
    # discover the dependencies without resorting to an actual build
    class FakeOrogenEnvironment
        class BlackHole
            def const_missing(*args)
                self
            end
            def method_missing(*args)
                self
            end
        end

        def self.orocos_target
            user_target = ENV['OROCOS_TARGET']
            if @orocos_target
                @orocos_target.dup
            elsif user_target && !user_target.empty?
                user_target
            else
                'gnulinux'
            end
        end

        attr_reader :project_name, :dependencies
        def self.load(file)
            FakeOrogenEnvironment.new.load(file)
        end

        def initialize
            @dependencies = Array.new
        end

        def load(file)
            Kernel.eval(File.read(file), binding)
            self
        end

        def name(name)
            @project_name = name
        end
        def using_library(*names)
            @dependencies.concat(names)
        end
        def using_toolkit(*names)
            names = names.map { |n| "#{n}-toolkit-#{FakeOrogenEnvironment.orocos_target}" }
            @dependencies.concat(names)
        end
        def using_task_library(*names)
            names = names.map { |n| "#{n}-tasks-#{FakeOrogenEnvironment.orocos_target}" }
            @dependencies.concat(names)
        end

        def const_missing(*args)
            BlackHole.new
        end
        def method_missing(*args)
            BlackHole.new
        end
    end

    # This class represents packages generated by orogen. oroGen is a
    # specification and code generation tool for the Orocos/RTT integration
    # framework. See http://doudou.github.com/orogen for more information.
    #
    # This class extends the CMake package class to handle the code generation
    # step. Moreover, it will load the orogen specification and automatically
    # add the relevant pkg-config dependencies as dependencies.
    #
    # This requires that the relevant packages define the pkg-config definitions
    # they install in the pkgconfig/ namespace. It means that a "driver/camera"
    # package (for instance) that installs a "camera.pc" file will have to
    # provide the "pkgconfig/camera" virtual package. This is done automatically
    # by the CMake package handler if the source contains a camera.pc.in file,
    # but can also be done manually with a call to Package#provides:
    #
    #   pkg.provides "pkgconfig/camera"
    #
    class Orogen < CMake
        class << self
            attr_accessor :corba
        end

        attr_reader :orogen_spec

        attr_accessor :corba

        attr_accessor :orogen_file
        def initialize(*args, &config)
            @corba       = Orogen.corba
            super

            @orogen_file ||= "#{File.basename(name)}.orogen"
        end

        def depends_on(*packages)
            super

            packages.each do |p|
                file genstamp => Package[p].installstamp
            end
        end

        def import
            super

            @orogen_spec = FakeOrogenEnvironment.load(File.join(srcdir, orogen_file))
            provides "pkgconfig/#{orogen_spec.project_name}-toolkit-#{FakeOrogenEnvironment.orocos_target}"
            provides "pkgconfig/#{orogen_spec.project_name}-tasks-#{FakeOrogenEnvironment.orocos_target}"
        end

        def prepare
            super

            # If required, load the component's specification and add
            # dependencies based on the orogen specification.
            orogen_spec.dependencies.each do |pkg_name|
                target = "pkgconfig/#{pkg_name}"
                if Autobuild::Package[target]
                    depends_on target
                end
            end

            # Find out where orogen is, and make sure the configurestamp depend
            # on it. Ignore if orogen is too old to have a --base-dir option
            orogen_root = File.join(`orogen --base-dir`.chomp, 'orogen')
            if !orogen_root.empty?
                file genstamp => Autobuild.source_tree(orogen_root)
            end

            file configurestamp => genstamp
            file genstamp => File.join(srcdir, orogen_file) do
                regen
            end
        end
        def genstamp; File.join(srcdir, '.orogen', 'orogen-stamp') end

        def regen
            cmdline = [Autobuild.tool('orogen')]
            cmdline << '--corba' if corba
            cmdline << orogen_file

            Autobuild.progress "generating oroGen project #{name}"
            Dir.chdir(srcdir) do
                Subprocess.run name, 'orogen', *cmdline
                Autobuild.touch_stamp genstamp
            end
        end
    end
end

